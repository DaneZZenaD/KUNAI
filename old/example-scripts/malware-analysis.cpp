// g++ -std=c++17 malware-analysis.cpp -o malware-analysis -lkunai

#include <iostream>
#include <memory>
#include <algorithm>
#include <utility>

#include <KUNAI/APK/apk.hpp>
#include <KUNAI/DEX/dex.hpp>
#include <KUNAI/mjolnIR/Lifters/lifter_android.hpp>

int
main (int argc, char **argv)
{
    if (argc != 3)
    {
        std::cerr << "USAGE: " << argv[0] << " <apk_file> <package_name>\n";
        return 1;
    }

    std::string apk_path = argv[1];
    std::string pkg_name_regex = argv[2];

    // check if we need to add L
    if (pkg_name_regex[0] != 'L')
        pkg_name_regex = "L" + pkg_name_regex;

    // replace . for /
    std::replace(pkg_name_regex.begin(), pkg_name_regex.end(), '.', '/');

    pkg_name_regex.append(".*");

    auto apk_file = KUNAI::APK::get_unique_apk_object(apk_path, true);

    apk_file->analyze_apk_file();

    auto analysis_object = apk_file->get_global_analysis();

    auto methods = analysis_object->find_methods(pkg_name_regex,".+",".+", ".+", true);

    std::cout << "Found " << methods.size() << " methods\n";

    KUNAI::MJOLNIR::irgraph_t graph;
    KUNAI::MJOLNIR::irgraph_t greatest;

    std::pair<std::uint64_t, KUNAI::DEX::MethodAnalysis*> more_complex_method;


    for (auto method : methods)
    {
        std::unique_ptr<KUNAI::LIFTER::LifterAndroid> lifter_android = std::make_unique<KUNAI::LIFTER::LifterAndroid>();

        graph = lifter_android->lift_android_method(method, analysis_object);
        
        auto cyclomatic_complexity = graph->get_cyclomatic_complexity();

        //std::cout << "Method " << method->full_name() << " has a cyclomatic complexity of: " << cyclomatic_complexity << "\n";

        if (cyclomatic_complexity > more_complex_method.first)
        {
            more_complex_method = std::make_pair(cyclomatic_complexity, method);
            greatest = graph;
        }
    }

    std::cout << "\n\nMethod with greater cyclomatic complexity: " << more_complex_method.second->full_name() << " with a complexity of: " << more_complex_method.first << std::endl;

    auto xrefs_to = more_complex_method.second->get_xref_to();

    std::cout << "Methods called by this method (" << xrefs_to.size() << "):\n";

    
    for (auto xref_to : xrefs_to)
        std::cout << "\tCalls to: " << std::get<1>(xref_to)->full_name() << "\n";

    auto xrefs_from = more_complex_method.second->get_xref_from();

    std::cout << "From where this method is called (" << xrefs_from.size() << "):\n";
    
    for (auto xref_from : xrefs_from)
        std::cout << "\tMethod called from: " << std::get<1>(xref_from)->full_name() << "\n";
    

    std::cout << "Dumping the method in the graph: " << more_complex_method.second->name() << ".dot\n";

    greatest->generate_dot_file("/results/"+more_complex_method.second->name());
    
    std::cout << "Dumping the dominator tree in dominator_tree.dot\n";

    greatest->generate_dominator_tree("/results/dominator_tree");

    return 0;
}